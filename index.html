/**
 * ปรับปรุง v3.18: Smart Trim & Enhanced Debugging
 * - แก้ปัญหาหาข้อมูลไม่เจอเพราะมีเว้นวรรค (Space) ในข้อมูล
 * - เพิ่ม Debug ให้แสดงข้อมูล 5 แถวล่าสุดเพื่อตรวจสอบความถูกต้อง
 */

const REQUIRED_COLUMNS = [
  "Timestamp", "Date", "Machine", "Shift", "Recorder", 
  "Product", "Hour", "FG", "NG_Total", "NG_Details_JSON", "Shift_Type"
];

function doGet(e) {
  try {
    const action = e.parameter.action;
    if (action === "GET_DASHBOARD") {
      const data = getAdvancedDashboardData(
        e.parameter.start, 
        e.parameter.end, 
        e.parameter.shift, 
        e.parameter.shiftType
      );
      return ContentService.createTextOutput(JSON.stringify(data))
        .setMimeType(ContentService.MimeType.JSON);
    }
    if (action === "DEBUG") {
      return ContentService.createTextOutput(JSON.stringify(debugSheetData()))
        .setMimeType(ContentService.MimeType.JSON);
    }
    return HtmlService.createHtmlOutput("CWM Smart API v3.18 (Smart Trim) is Online");
  } catch (err) {
    return ContentService.createTextOutput(JSON.stringify({error: err.toString()}))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

function doPost(e) {
  try {
    const data = JSON.parse(e.postData.contents);

    // --- CASE 1: PRODUCTION ---
    if (data.action === 'SAVE_PRODUCTION') {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      let sheet = ss.getSheetByName("Production_Data") || ss.insertSheet("Production_Data");
      syncHeaders(sheet);
      
      const now = new Date();
      const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
      const newRow = new Array(headers.length).fill("");
      
      const getColIndex = (name) => headers.findIndex(h => h.toString().trim().toLowerCase() === name.toLowerCase());
      const mapData = (colName, value) => {
        const idx = getColIndex(colName);
        if (idx !== -1) newRow[idx] = value;
      };

      mapData("Timestamp", data.timestamp || now.toLocaleString('th-TH'));
      mapData("Date", data.productionDate || Utilities.formatDate(now, "GMT+7", "yyyy-MM-dd"));
      mapData("Machine", data.machine || "-");
      mapData("Shift", data.shift || "A");
      mapData("Recorder", data.recorder || "-");
      mapData("Product", data.productCode || "-");
      mapData("Hour", data.hourSlot || "-");
      mapData("FG", parseInt(data.fgAmount) || 0);
      
      const totalNg = (data.ngDetails || []).reduce((sum, item) => sum + (parseInt(item.qty) || 0), 0);
      mapData("NG_Total", totalNg);
      mapData("NG_Details_JSON", JSON.stringify(data.ngDetails || []));
      mapData("Shift_Type", data.shiftType || "Day");

      sheet.appendRow(newRow);
      return ContentService.createTextOutput(JSON.stringify({status: "success", message: "Production Saved"}))
        .setMimeType(ContentService.MimeType.JSON);
    }

    // --- CASE 2: PLANNING ---
    else if (data.action === 'SAVE_PLAN') {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      let sheet = ss.getSheetByName("Plan_Data");
      
      if (!sheet) {
        sheet = ss.insertSheet("Plan_Data");
        sheet.appendRow(["Date", "Product", "Target_Qty", "Shift", "Timestamp"]);
      }
      
      const now = new Date();
      sheet.appendRow([
        data.planDate,          
        data.product,           
        parseInt(data.qty) || 0,
        data.shift || "All",    
        now.toLocaleString('th-TH') 
      ]);
      
      return ContentService.createTextOutput(JSON.stringify({status: "success", message: "Plan Saved"}))
        .setMimeType(ContentService.MimeType.JSON);
    }

    else {
      return ContentService.createTextOutput(JSON.stringify({status: "error", message: "Unknown Action"}))
        .setMimeType(ContentService.MimeType.JSON);
    }

  } catch (error) {
    return ContentService.createTextOutput(JSON.stringify({status: "error", message: error.toString()}))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

function syncHeaders(sheet) {
  if (sheet.getLastRow() === 0) {
    sheet.appendRow(REQUIRED_COLUMNS);
    return;
  }
  const currentHeaders = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0].map(h => h.toString().trim());
  const missingHeaders = REQUIRED_COLUMNS.filter(h => !currentHeaders.includes(h));
  if (missingHeaders.length > 0) {
    const lastCol = sheet.getLastColumn();
    sheet.getRange(1, lastCol + 1, 1, missingHeaders.length).setValues([missingHeaders]);
  }
}

function getProductionTarget(startDate, endDate) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let planSheet = ss.getSheetByName("Plan_Data");
  if (!planSheet) return { total: 0, byProduct: {} };
  
  const data = planSheet.getDataRange().getValues();
  if (data.length <= 1) return { total: 0, byProduct: {} };
  
  let totalTarget = 0;
  let byProduct = {};

  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    let rowDate = row[0];
    let product = "All";
    let targetQty = 0;

    if (isNaN(parseInt(row[1]))) {
       product = row[1] || "Unknown";
       targetQty = parseInt(row[2]) || 0;
    } else {
       targetQty = parseInt(row[1]) || 0;
    }
    
    let rowDateStr = (rowDate instanceof Date) ? Utilities.formatDate(rowDate, "GMT+7", "yyyy-MM-dd") : String(rowDate).trim().substring(0, 10);
    
    if (rowDateStr >= startDate && rowDateStr <= endDate) {
      totalTarget += targetQty;
      if (!byProduct[product]) byProduct[product] = 0;
      byProduct[product] += targetQty;
    }
  }
  return { total: totalTarget, byProduct: byProduct };
}

function getAdvancedDashboardData(reqStart, reqEnd, reqShift, reqType) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName("Production_Data");
  
  const today = Utilities.formatDate(new Date(), "GMT+7", "yyyy-MM-dd");
  const startDate = reqStart || today;
  const endDate = reqEnd || today;
  const filterShift = reqShift || "All";
  const filterType = reqType || "All";

  const DAY_HOURS = ["08:00-09:00", "09:00-10:00", "10:00-11:00", "11:00-12:00", "12:00-13:00", "13:00-14:00", "14:00-15:00", "15:00-16:00", "16:00-17:00", "OT 17:30-18:00", "OT 18:00-19:00", "OT 19:00-20:00"];
  const NIGHT_HOURS = ["20:00-21:00", "21:00-22:00", "22:00-23:00", "23:00-00:00", "00:00-01:00", "01:00-02:00", "02:00-03:00", "03:00-04:00", "04:00-05:00", "OT 05:00-06:30", "OT 06:00-07:30", "OT 07:00-08:00"];
  
  let displayLabels = (filterType === "Day") ? DAY_HOURS : (filterType === "Night" ? NIGHT_HOURS : [...DAY_HOURS, ...NIGHT_HOURS]);

  const planData = getProductionTarget(startDate, endDate);

  const result = {
    productionTarget: planData.total,
    productionPlanByModel: planData.byProduct,
    totalFg: 0, totalNg: 0,
    hourlyLabels: displayLabels,
    hourlyData: Array(displayLabels.length).fill(0),
    hourlyNgData: Array(displayLabels.length).fill(0),
    ngLabels: [], ngValues: [],
    machineData: {}, productData: {}, dailyTrend: []
  };

  if (!sheet) return result;
  const dataRange = sheet.getDataRange().getValues();
  if (dataRange.length <= 1) return result; 
  
  const headers = dataRange[0];
  const rows = dataRange.slice(1);
  const col = {};
  headers.forEach((name, index) => { col[name.toString().trim().toLowerCase()] = index; });
  const getVal = (row, colName) => { const idx = col[colName.toLowerCase()]; return (idx !== undefined) ? row[idx] : undefined; };

  const ngTempMap = {};
  const dailyStats = {};

  rows.forEach(row => {
    try {
      const rowDateRaw = getVal(row, "Date");
      if (!rowDateRaw) return;
      let rowDateStr = (rowDateRaw instanceof Date) ? Utilities.formatDate(rowDateRaw, "GMT+7", "yyyy-MM-dd") : String(rowDateRaw).trim().substring(0, 10);
      
      if (rowDateStr >= startDate && rowDateStr <= endDate) {
        // *** Smart Trim Added *** ตัดช่องว่างหัวท้ายทิ้ง
        const shiftName = String(getVal(row, "Shift") || "A").trim();
        const shiftType = String(getVal(row, "Shift_Type") || "Day").trim();

        if (filterShift !== "All" && shiftName !== filterShift) return;
        if (filterType !== "All" && shiftType !== filterType) return;

        const machine = String(getVal(row, "Machine") || "Unknown").trim();
        const product = String(getVal(row, "Product") || "Unknown").trim();
        const hour = String(getVal(row, "Hour") || "-").trim();
        const fg = parseInt(getVal(row, "FG")) || 0;
        const ngTotal = parseInt(getVal(row, "NG_Total")) || 0;
        let details = []; try { const j = getVal(row, "NG_Details_JSON"); if(j) details = JSON.parse(j); } catch (e) {}

        result.totalFg += fg;
        result.totalNg += ngTotal;

        if (!dailyStats[rowDateStr]) dailyStats[rowDateStr] = { fg: 0, ng: 0 };
        dailyStats[rowDateStr].fg += fg;
        dailyStats[rowDateStr].ng += ngTotal;

        const hIdx = displayLabels.indexOf(hour);
        if (hIdx !== -1) {
           result.hourlyData[hIdx] += fg;
           result.hourlyNgData[hIdx] += ngTotal;
        }

        if (!result.machineData[machine]) {
          result.machineData[machine] = { 
            fg: 0, ngTotal: 0, ngBreakdown: {}, remarks: [],
            hourlyFg: Array(displayLabels.length).fill(0),
            hourlyNg: Array(displayLabels.length).fill(0)
          };
        }
        result.machineData[machine].fg += fg;
        result.machineData[machine].ngTotal += ngTotal;
        
        if (hIdx !== -1) {
            result.machineData[machine].hourlyFg[hIdx] += fg;
            result.machineData[machine].hourlyNg[hIdx] += ngTotal;
        }

        if (!result.productData[product]) result.productData[product] = { fg: 0, ngTotal: 0 };
        result.productData[product].fg += fg;
        result.productData[product].ngTotal += ngTotal;

        details.forEach(item => {
          if (item.type) {
            ngTempMap[item.type] = (ngTempMap[item.type] || 0) + (parseInt(item.qty) || 0);
            result.machineData[machine].ngBreakdown[item.type] = (result.machineData[machine].ngBreakdown[item.type] || 0) + (parseInt(item.qty) || 0);
            if (item.remark) result.machineData[machine].remarks.push(`[${item.type}] ${item.remark}`);
          }
        });
      }
    } catch (e) { console.log("Row error: " + e); }
  });

  result.ngLabels = Object.keys(ngTempMap);
  result.ngValues = Object.values(ngTempMap);
  const sortedDates = Object.keys(dailyStats).sort();
  result.dailyTrend = sortedDates.map(date => {
    const d = dailyStats[date];
    const total = d.fg + d.ng;
    const rate = total > 0 ? ((d.ng / total) * 100).toFixed(2) : 0;
    return { date: date, ngRate: parseFloat(rate) };
  });

  return result;
}

// *** New Debug Logic ***
function debugSheetData() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName("Production_Data");
  if (!sheet) return { error: "Production_Data not found" };
  
  const values = sheet.getDataRange().getValues();
  const headers = values[0];
  
  // Show detailed last 5 rows
  const lastRows = values.slice(-5).map(r => {
      // Map row index to header name for easier reading
      let obj = {};
      headers.forEach((h, i) => {
          obj[h] = r[i];
      });
      // Format date for check
      if (obj['Date'] instanceof Date) {
          obj['Date_Formatted'] = Utilities.formatDate(obj['Date'], "GMT+7", "yyyy-MM-dd");
      }
      return obj;
  });

  return { 
      status: "DEBUG_V3.18", 
      totalRows: values.length, 
      headersFound: headers,
      last5Rows: lastRows // ส่งข้อมูลตัวอย่างกลับมาดู
  };
}
